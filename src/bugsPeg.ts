/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* // This grammar of the BUGS language is created with manual inspectation of the OpenBUGS manual.
* // Although this grammar has been tested with 240 programs extracted from OpenBUGS documents (only 2 programs were not parsed and they are all data definition written in rectangular format, support of which is a non-goal), I am not sure if this grammar is comprehensive enough.
* // Firemodel.txt includes a line `xa ~ dlnorm( mu, tau ) I( , theta )`. This syntax is not documented in OpenBUGS manual.
* program  := before=sep body=programBody after=sep
* programBody := list | rectangular | sectionList
* rectangular := header=rectangularHeader body={sep=rowSep item=rectangularBodyItem}* sep=sep footer=rectangularFooter
* colSep := blank
* rowSep := blank '[\n]' | blank comment=comment
* rectangularHeader := content={sep=colSep item=name '\[\]'}+
* rectangularFooter := colSep 'END'
* rectangularBodyItem := content={sep=colSep item=scalar}+
* section := header=sectionHeader sep=sep body=block
* sectionHeader := v='model' | v='data'
* sectionList := head=section tail={sep=sep item=section}*
* block := '{' before=relationSep body=relationList after=relationSep '}'
* relation    := stochasticRelation | deterministicRelation | indexedRelation
* relationSep := body={sep=blank item=relationSepItem}* blank
* relationSepItem := sepItem | v=';'
* relationList := head=relation tail={sep=relationSep item=relation}*
* cti := sep header=ctiHeader '[(]' sep lower=exp? '[,]' sep upper=exp?  sep'[)]'
* ctiHeader := v='C' | v='T' | v='I'
* stochasticRelation      := lhs=exp beforeOp=sep '~' afterOp=sep rhs=exp cti=cti?
* deterministicRelation   := lhs=exp beforeOp=sep '<-' afterOp=sep rhs=exp
* indexedRelation         := 'for' blank '\(' blank name=name blank 'in' blank domain=exp blank '\)' afterParenR=sep body=block
* // simple concepts
* blank   := v='[^\S\n]*'
* newline := v='[\n]'
* comment := '[#]' content='[^\n]*' '[\n]'
* sep     := body={sep=blank item=sepItem}* blank
* sepItem := newline | comment
* exp  := exp5
* exp0 := scalar | structure | list | '\(' before=sep exp=exp5 after=sep '\)' | name 
* exp1 := base=exp0 applications=application*
* exp2 := '-' between=sep exp=exp1 | exp1
* exp3 := left=exp3 beforeOp=sep op=addSub afterOp=sep right=exp2 | exp2
* exp4 := left=exp4 beforeOp=sep op=mulDiv afterOp=sep right=exp3 | exp3
* exp5 := left=exp5 beforeOp=sep ':' afterOp=sep right=exp4 | exp4 
* application := functionApplication | vectorApplication
* functionApplication := beforeParen=sep '\(' beginArgs=sep operands=argumentList endArgs=sep '\)'
* vectorApplication := beforeParen=sep '\[' beginInds=sep operands=indexList endInds=sep '\]'
* addSub := v='\+' | v='-'
* mulDiv := v='\*' | v='/'
* list := 'list[(]' beforeFields=sep operands=fieldList afterFields=sep '[)]'
* structure := 'structure[(]' begin=sep '\.' sepDotData=sep 'Data' eqData=nameValueSep data=exp operandSep '\.' sepDotDim=sep 'Dim' eqDim=nameValueSep dim=exp end=sep '[)]'
* operandSep := before=sep ',' after=sep
* argument     := exp
* argumentList := content={first=argument rest={sep=operandSep item=argument}*}?
* indexList := content={first=exp? rest={sep=operandSep item=exp?}*}?
* field     := name=name sep=nameValueSep value=exp
* fieldList := content={first=field rest={sep=operandSep item=field}*}?
* nameValueSep  := before=sep '=' after=sep
* name := from=@ value='[a-zA-Z][a-zA-Z0-9._]*' to=@
* scalar := value='-?([\d]+([.][\d]+)?|([\d]+)?[.][\d]+)([eE]-?[\d]+)?'
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    program = "program",
    programBody_1 = "programBody_1",
    programBody_2 = "programBody_2",
    programBody_3 = "programBody_3",
    rectangular = "rectangular",
    rectangular_$0 = "rectangular_$0",
    colSep = "colSep",
    rowSep_1 = "rowSep_1",
    rowSep_2 = "rowSep_2",
    rectangularHeader = "rectangularHeader",
    rectangularHeader_$0 = "rectangularHeader_$0",
    rectangularFooter = "rectangularFooter",
    rectangularBodyItem = "rectangularBodyItem",
    rectangularBodyItem_$0 = "rectangularBodyItem_$0",
    section = "section",
    sectionHeader_1 = "sectionHeader_1",
    sectionHeader_2 = "sectionHeader_2",
    sectionList = "sectionList",
    sectionList_$0 = "sectionList_$0",
    block = "block",
    relation_1 = "relation_1",
    relation_2 = "relation_2",
    relation_3 = "relation_3",
    relationSep = "relationSep",
    relationSep_$0 = "relationSep_$0",
    relationSepItem_1 = "relationSepItem_1",
    relationSepItem_2 = "relationSepItem_2",
    relationList = "relationList",
    relationList_$0 = "relationList_$0",
    cti = "cti",
    ctiHeader_1 = "ctiHeader_1",
    ctiHeader_2 = "ctiHeader_2",
    ctiHeader_3 = "ctiHeader_3",
    stochasticRelation = "stochasticRelation",
    deterministicRelation = "deterministicRelation",
    indexedRelation = "indexedRelation",
    blank = "blank",
    newline = "newline",
    comment = "comment",
    sep = "sep",
    sep_$0 = "sep_$0",
    sepItem_1 = "sepItem_1",
    sepItem_2 = "sepItem_2",
    exp = "exp",
    exp0_1 = "exp0_1",
    exp0_2 = "exp0_2",
    exp0_3 = "exp0_3",
    exp0_4 = "exp0_4",
    exp0_5 = "exp0_5",
    exp1 = "exp1",
    exp2_1 = "exp2_1",
    exp2_2 = "exp2_2",
    exp3_1 = "exp3_1",
    exp3_2 = "exp3_2",
    exp4_1 = "exp4_1",
    exp4_2 = "exp4_2",
    exp5_1 = "exp5_1",
    exp5_2 = "exp5_2",
    application_1 = "application_1",
    application_2 = "application_2",
    functionApplication = "functionApplication",
    vectorApplication = "vectorApplication",
    addSub_1 = "addSub_1",
    addSub_2 = "addSub_2",
    mulDiv_1 = "mulDiv_1",
    mulDiv_2 = "mulDiv_2",
    list = "list",
    structure = "structure",
    operandSep = "operandSep",
    argument = "argument",
    argumentList = "argumentList",
    argumentList_$0 = "argumentList_$0",
    argumentList_$0_$0 = "argumentList_$0_$0",
    indexList = "indexList",
    indexList_$0 = "indexList_$0",
    indexList_$0_$0 = "indexList_$0_$0",
    field = "field",
    fieldList = "fieldList",
    fieldList_$0 = "fieldList_$0",
    fieldList_$0_$0 = "fieldList_$0_$0",
    nameValueSep = "nameValueSep",
    name = "name",
    scalar = "scalar",
}
export interface program {
    kind: ASTKinds.program;
    before: sep;
    body: programBody;
    after: sep;
}
export type programBody = programBody_1 | programBody_2 | programBody_3;
export type programBody_1 = list;
export type programBody_2 = rectangular;
export type programBody_3 = sectionList;
export interface rectangular {
    kind: ASTKinds.rectangular;
    header: rectangularHeader;
    body: rectangular_$0[];
    sep: sep;
    footer: rectangularFooter;
}
export interface rectangular_$0 {
    kind: ASTKinds.rectangular_$0;
    sep: rowSep;
    item: rectangularBodyItem;
}
export type colSep = blank;
export type rowSep = rowSep_1 | rowSep_2;
export interface rowSep_1 {
    kind: ASTKinds.rowSep_1;
}
export interface rowSep_2 {
    kind: ASTKinds.rowSep_2;
    comment: comment;
}
export interface rectangularHeader {
    kind: ASTKinds.rectangularHeader;
    content: rectangularHeader_$0[];
}
export interface rectangularHeader_$0 {
    kind: ASTKinds.rectangularHeader_$0;
    sep: colSep;
    item: name;
}
export interface rectangularFooter {
    kind: ASTKinds.rectangularFooter;
}
export interface rectangularBodyItem {
    kind: ASTKinds.rectangularBodyItem;
    content: rectangularBodyItem_$0[];
}
export interface rectangularBodyItem_$0 {
    kind: ASTKinds.rectangularBodyItem_$0;
    sep: colSep;
    item: scalar;
}
export interface section {
    kind: ASTKinds.section;
    header: sectionHeader;
    sep: sep;
    body: block;
}
export type sectionHeader = sectionHeader_1 | sectionHeader_2;
export interface sectionHeader_1 {
    kind: ASTKinds.sectionHeader_1;
    v: string;
}
export interface sectionHeader_2 {
    kind: ASTKinds.sectionHeader_2;
    v: string;
}
export interface sectionList {
    kind: ASTKinds.sectionList;
    head: section;
    tail: sectionList_$0[];
}
export interface sectionList_$0 {
    kind: ASTKinds.sectionList_$0;
    sep: sep;
    item: section;
}
export interface block {
    kind: ASTKinds.block;
    before: relationSep;
    body: relationList;
    after: relationSep;
}
export type relation = relation_1 | relation_2 | relation_3;
export type relation_1 = stochasticRelation;
export type relation_2 = deterministicRelation;
export type relation_3 = indexedRelation;
export interface relationSep {
    kind: ASTKinds.relationSep;
    body: relationSep_$0[];
}
export interface relationSep_$0 {
    kind: ASTKinds.relationSep_$0;
    sep: blank;
    item: relationSepItem;
}
export type relationSepItem = relationSepItem_1 | relationSepItem_2;
export type relationSepItem_1 = sepItem;
export interface relationSepItem_2 {
    kind: ASTKinds.relationSepItem_2;
    v: string;
}
export interface relationList {
    kind: ASTKinds.relationList;
    head: relation;
    tail: relationList_$0[];
}
export interface relationList_$0 {
    kind: ASTKinds.relationList_$0;
    sep: relationSep;
    item: relation;
}
export interface cti {
    kind: ASTKinds.cti;
    header: ctiHeader;
    lower: Nullable<exp>;
    upper: Nullable<exp>;
}
export type ctiHeader = ctiHeader_1 | ctiHeader_2 | ctiHeader_3;
export interface ctiHeader_1 {
    kind: ASTKinds.ctiHeader_1;
    v: string;
}
export interface ctiHeader_2 {
    kind: ASTKinds.ctiHeader_2;
    v: string;
}
export interface ctiHeader_3 {
    kind: ASTKinds.ctiHeader_3;
    v: string;
}
export interface stochasticRelation {
    kind: ASTKinds.stochasticRelation;
    lhs: exp;
    beforeOp: sep;
    afterOp: sep;
    rhs: exp;
    cti: Nullable<cti>;
}
export interface deterministicRelation {
    kind: ASTKinds.deterministicRelation;
    lhs: exp;
    beforeOp: sep;
    afterOp: sep;
    rhs: exp;
}
export interface indexedRelation {
    kind: ASTKinds.indexedRelation;
    name: name;
    domain: exp;
    afterParenR: sep;
    body: block;
}
export interface blank {
    kind: ASTKinds.blank;
    v: string;
}
export interface newline {
    kind: ASTKinds.newline;
    v: string;
}
export interface comment {
    kind: ASTKinds.comment;
    content: string;
}
export interface sep {
    kind: ASTKinds.sep;
    body: sep_$0[];
}
export interface sep_$0 {
    kind: ASTKinds.sep_$0;
    sep: blank;
    item: sepItem;
}
export type sepItem = sepItem_1 | sepItem_2;
export type sepItem_1 = newline;
export type sepItem_2 = comment;
export type exp = exp5;
export type exp0 = exp0_1 | exp0_2 | exp0_3 | exp0_4 | exp0_5;
export type exp0_1 = scalar;
export type exp0_2 = structure;
export type exp0_3 = list;
export interface exp0_4 {
    kind: ASTKinds.exp0_4;
    before: sep;
    exp: exp5;
    after: sep;
}
export type exp0_5 = name;
export interface exp1 {
    kind: ASTKinds.exp1;
    base: exp0;
    applications: application[];
}
export type exp2 = exp2_1 | exp2_2;
export interface exp2_1 {
    kind: ASTKinds.exp2_1;
    between: sep;
    exp: exp1;
}
export type exp2_2 = exp1;
export type exp3 = exp3_1 | exp3_2;
export interface exp3_1 {
    kind: ASTKinds.exp3_1;
    left: exp3;
    beforeOp: sep;
    op: addSub;
    afterOp: sep;
    right: exp2;
}
export type exp3_2 = exp2;
export type exp4 = exp4_1 | exp4_2;
export interface exp4_1 {
    kind: ASTKinds.exp4_1;
    left: exp4;
    beforeOp: sep;
    op: mulDiv;
    afterOp: sep;
    right: exp3;
}
export type exp4_2 = exp3;
export type exp5 = exp5_1 | exp5_2;
export interface exp5_1 {
    kind: ASTKinds.exp5_1;
    left: exp5;
    beforeOp: sep;
    afterOp: sep;
    right: exp4;
}
export type exp5_2 = exp4;
export type application = application_1 | application_2;
export type application_1 = functionApplication;
export type application_2 = vectorApplication;
export interface functionApplication {
    kind: ASTKinds.functionApplication;
    beforeParen: sep;
    beginArgs: sep;
    operands: argumentList;
    endArgs: sep;
}
export interface vectorApplication {
    kind: ASTKinds.vectorApplication;
    beforeParen: sep;
    beginInds: sep;
    operands: indexList;
    endInds: sep;
}
export type addSub = addSub_1 | addSub_2;
export interface addSub_1 {
    kind: ASTKinds.addSub_1;
    v: string;
}
export interface addSub_2 {
    kind: ASTKinds.addSub_2;
    v: string;
}
export type mulDiv = mulDiv_1 | mulDiv_2;
export interface mulDiv_1 {
    kind: ASTKinds.mulDiv_1;
    v: string;
}
export interface mulDiv_2 {
    kind: ASTKinds.mulDiv_2;
    v: string;
}
export interface list {
    kind: ASTKinds.list;
    beforeFields: sep;
    operands: fieldList;
    afterFields: sep;
}
export interface structure {
    kind: ASTKinds.structure;
    begin: sep;
    sepDotData: sep;
    eqData: nameValueSep;
    data: exp;
    sepDotDim: sep;
    eqDim: nameValueSep;
    dim: exp;
    end: sep;
}
export interface operandSep {
    kind: ASTKinds.operandSep;
    before: sep;
    after: sep;
}
export type argument = exp;
export interface argumentList {
    kind: ASTKinds.argumentList;
    content: Nullable<argumentList_$0>;
}
export interface argumentList_$0 {
    kind: ASTKinds.argumentList_$0;
    first: argument;
    rest: argumentList_$0_$0[];
}
export interface argumentList_$0_$0 {
    kind: ASTKinds.argumentList_$0_$0;
    sep: operandSep;
    item: argument;
}
export interface indexList {
    kind: ASTKinds.indexList;
    content: Nullable<indexList_$0>;
}
export interface indexList_$0 {
    kind: ASTKinds.indexList_$0;
    first: Nullable<exp>;
    rest: indexList_$0_$0[];
}
export interface indexList_$0_$0 {
    kind: ASTKinds.indexList_$0_$0;
    sep: operandSep;
    item: Nullable<exp>;
}
export interface field {
    kind: ASTKinds.field;
    name: name;
    sep: nameValueSep;
    value: exp;
}
export interface fieldList {
    kind: ASTKinds.fieldList;
    content: Nullable<fieldList_$0>;
}
export interface fieldList_$0 {
    kind: ASTKinds.fieldList_$0;
    first: field;
    rest: fieldList_$0_$0[];
}
export interface fieldList_$0_$0 {
    kind: ASTKinds.fieldList_$0_$0;
    sep: operandSep;
    item: field;
}
export interface nameValueSep {
    kind: ASTKinds.nameValueSep;
    before: sep;
    after: sep;
}
export interface name {
    kind: ASTKinds.name;
    from: PosInfo;
    value: string;
    to: PosInfo;
}
export interface scalar {
    kind: ASTKinds.scalar;
    value: string;
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
        this.$scope$exp3$memo.clear();
        this.$scope$exp4$memo.clear();
        this.$scope$exp5$memo.clear();
    }
    protected $scope$exp3$memo: Map<number, [Nullable<exp3>, PosInfo]> = new Map();
    protected $scope$exp4$memo: Map<number, [Nullable<exp4>, PosInfo]> = new Map();
    protected $scope$exp5$memo: Map<number, [Nullable<exp5>, PosInfo]> = new Map();
    public matchprogram($$dpth: number, $$cr?: ErrorTracker): Nullable<program> {
        return this.run<program>($$dpth,
            () => {
                let $scope$before: Nullable<sep>;
                let $scope$body: Nullable<programBody>;
                let $scope$after: Nullable<sep>;
                let $$res: Nullable<program> = null;
                if (true
                    && ($scope$before = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$body = this.matchprogramBody($$dpth + 1, $$cr)) !== null
                    && ($scope$after = this.matchsep($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.program, before: $scope$before, body: $scope$body, after: $scope$after};
                }
                return $$res;
            });
    }
    public matchprogramBody($$dpth: number, $$cr?: ErrorTracker): Nullable<programBody> {
        return this.choice<programBody>([
            () => this.matchprogramBody_1($$dpth + 1, $$cr),
            () => this.matchprogramBody_2($$dpth + 1, $$cr),
            () => this.matchprogramBody_3($$dpth + 1, $$cr),
        ]);
    }
    public matchprogramBody_1($$dpth: number, $$cr?: ErrorTracker): Nullable<programBody_1> {
        return this.matchlist($$dpth + 1, $$cr);
    }
    public matchprogramBody_2($$dpth: number, $$cr?: ErrorTracker): Nullable<programBody_2> {
        return this.matchrectangular($$dpth + 1, $$cr);
    }
    public matchprogramBody_3($$dpth: number, $$cr?: ErrorTracker): Nullable<programBody_3> {
        return this.matchsectionList($$dpth + 1, $$cr);
    }
    public matchrectangular($$dpth: number, $$cr?: ErrorTracker): Nullable<rectangular> {
        return this.run<rectangular>($$dpth,
            () => {
                let $scope$header: Nullable<rectangularHeader>;
                let $scope$body: Nullable<rectangular_$0[]>;
                let $scope$sep: Nullable<sep>;
                let $scope$footer: Nullable<rectangularFooter>;
                let $$res: Nullable<rectangular> = null;
                if (true
                    && ($scope$header = this.matchrectangularHeader($$dpth + 1, $$cr)) !== null
                    && ($scope$body = this.loop<rectangular_$0>(() => this.matchrectangular_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$sep = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$footer = this.matchrectangularFooter($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.rectangular, header: $scope$header, body: $scope$body, sep: $scope$sep, footer: $scope$footer};
                }
                return $$res;
            });
    }
    public matchrectangular_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<rectangular_$0> {
        return this.run<rectangular_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<rowSep>;
                let $scope$item: Nullable<rectangularBodyItem>;
                let $$res: Nullable<rectangular_$0> = null;
                if (true
                    && ($scope$sep = this.matchrowSep($$dpth + 1, $$cr)) !== null
                    && ($scope$item = this.matchrectangularBodyItem($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.rectangular_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchcolSep($$dpth: number, $$cr?: ErrorTracker): Nullable<colSep> {
        return this.matchblank($$dpth + 1, $$cr);
    }
    public matchrowSep($$dpth: number, $$cr?: ErrorTracker): Nullable<rowSep> {
        return this.choice<rowSep>([
            () => this.matchrowSep_1($$dpth + 1, $$cr),
            () => this.matchrowSep_2($$dpth + 1, $$cr),
        ]);
    }
    public matchrowSep_1($$dpth: number, $$cr?: ErrorTracker): Nullable<rowSep_1> {
        return this.run<rowSep_1>($$dpth,
            () => {
                let $$res: Nullable<rowSep_1> = null;
                if (true
                    && this.matchblank($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:[\n])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.rowSep_1, };
                }
                return $$res;
            });
    }
    public matchrowSep_2($$dpth: number, $$cr?: ErrorTracker): Nullable<rowSep_2> {
        return this.run<rowSep_2>($$dpth,
            () => {
                let $scope$comment: Nullable<comment>;
                let $$res: Nullable<rowSep_2> = null;
                if (true
                    && this.matchblank($$dpth + 1, $$cr) !== null
                    && ($scope$comment = this.matchcomment($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.rowSep_2, comment: $scope$comment};
                }
                return $$res;
            });
    }
    public matchrectangularHeader($$dpth: number, $$cr?: ErrorTracker): Nullable<rectangularHeader> {
        return this.run<rectangularHeader>($$dpth,
            () => {
                let $scope$content: Nullable<rectangularHeader_$0[]>;
                let $$res: Nullable<rectangularHeader> = null;
                if (true
                    && ($scope$content = this.loop<rectangularHeader_$0>(() => this.matchrectangularHeader_$0($$dpth + 1, $$cr), false)) !== null
                ) {
                    $$res = {kind: ASTKinds.rectangularHeader, content: $scope$content};
                }
                return $$res;
            });
    }
    public matchrectangularHeader_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<rectangularHeader_$0> {
        return this.run<rectangularHeader_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<colSep>;
                let $scope$item: Nullable<name>;
                let $$res: Nullable<rectangularHeader_$0> = null;
                if (true
                    && ($scope$sep = this.matchcolSep($$dpth + 1, $$cr)) !== null
                    && ($scope$item = this.matchname($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\[\])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.rectangularHeader_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchrectangularFooter($$dpth: number, $$cr?: ErrorTracker): Nullable<rectangularFooter> {
        return this.run<rectangularFooter>($$dpth,
            () => {
                let $$res: Nullable<rectangularFooter> = null;
                if (true
                    && this.matchcolSep($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:END)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.rectangularFooter, };
                }
                return $$res;
            });
    }
    public matchrectangularBodyItem($$dpth: number, $$cr?: ErrorTracker): Nullable<rectangularBodyItem> {
        return this.run<rectangularBodyItem>($$dpth,
            () => {
                let $scope$content: Nullable<rectangularBodyItem_$0[]>;
                let $$res: Nullable<rectangularBodyItem> = null;
                if (true
                    && ($scope$content = this.loop<rectangularBodyItem_$0>(() => this.matchrectangularBodyItem_$0($$dpth + 1, $$cr), false)) !== null
                ) {
                    $$res = {kind: ASTKinds.rectangularBodyItem, content: $scope$content};
                }
                return $$res;
            });
    }
    public matchrectangularBodyItem_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<rectangularBodyItem_$0> {
        return this.run<rectangularBodyItem_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<colSep>;
                let $scope$item: Nullable<scalar>;
                let $$res: Nullable<rectangularBodyItem_$0> = null;
                if (true
                    && ($scope$sep = this.matchcolSep($$dpth + 1, $$cr)) !== null
                    && ($scope$item = this.matchscalar($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.rectangularBodyItem_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchsection($$dpth: number, $$cr?: ErrorTracker): Nullable<section> {
        return this.run<section>($$dpth,
            () => {
                let $scope$header: Nullable<sectionHeader>;
                let $scope$sep: Nullable<sep>;
                let $scope$body: Nullable<block>;
                let $$res: Nullable<section> = null;
                if (true
                    && ($scope$header = this.matchsectionHeader($$dpth + 1, $$cr)) !== null
                    && ($scope$sep = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$body = this.matchblock($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.section, header: $scope$header, sep: $scope$sep, body: $scope$body};
                }
                return $$res;
            });
    }
    public matchsectionHeader($$dpth: number, $$cr?: ErrorTracker): Nullable<sectionHeader> {
        return this.choice<sectionHeader>([
            () => this.matchsectionHeader_1($$dpth + 1, $$cr),
            () => this.matchsectionHeader_2($$dpth + 1, $$cr),
        ]);
    }
    public matchsectionHeader_1($$dpth: number, $$cr?: ErrorTracker): Nullable<sectionHeader_1> {
        return this.run<sectionHeader_1>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<sectionHeader_1> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:model)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.sectionHeader_1, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchsectionHeader_2($$dpth: number, $$cr?: ErrorTracker): Nullable<sectionHeader_2> {
        return this.run<sectionHeader_2>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<sectionHeader_2> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:data)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.sectionHeader_2, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchsectionList($$dpth: number, $$cr?: ErrorTracker): Nullable<sectionList> {
        return this.run<sectionList>($$dpth,
            () => {
                let $scope$head: Nullable<section>;
                let $scope$tail: Nullable<sectionList_$0[]>;
                let $$res: Nullable<sectionList> = null;
                if (true
                    && ($scope$head = this.matchsection($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<sectionList_$0>(() => this.matchsectionList_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.sectionList, head: $scope$head, tail: $scope$tail};
                }
                return $$res;
            });
    }
    public matchsectionList_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<sectionList_$0> {
        return this.run<sectionList_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<sep>;
                let $scope$item: Nullable<section>;
                let $$res: Nullable<sectionList_$0> = null;
                if (true
                    && ($scope$sep = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$item = this.matchsection($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.sectionList_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchblock($$dpth: number, $$cr?: ErrorTracker): Nullable<block> {
        return this.run<block>($$dpth,
            () => {
                let $scope$before: Nullable<relationSep>;
                let $scope$body: Nullable<relationList>;
                let $scope$after: Nullable<relationSep>;
                let $$res: Nullable<block> = null;
                if (true
                    && this.regexAccept(String.raw`(?:{)`, $$dpth + 1, $$cr) !== null
                    && ($scope$before = this.matchrelationSep($$dpth + 1, $$cr)) !== null
                    && ($scope$body = this.matchrelationList($$dpth + 1, $$cr)) !== null
                    && ($scope$after = this.matchrelationSep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:})`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.block, before: $scope$before, body: $scope$body, after: $scope$after};
                }
                return $$res;
            });
    }
    public matchrelation($$dpth: number, $$cr?: ErrorTracker): Nullable<relation> {
        return this.choice<relation>([
            () => this.matchrelation_1($$dpth + 1, $$cr),
            () => this.matchrelation_2($$dpth + 1, $$cr),
            () => this.matchrelation_3($$dpth + 1, $$cr),
        ]);
    }
    public matchrelation_1($$dpth: number, $$cr?: ErrorTracker): Nullable<relation_1> {
        return this.matchstochasticRelation($$dpth + 1, $$cr);
    }
    public matchrelation_2($$dpth: number, $$cr?: ErrorTracker): Nullable<relation_2> {
        return this.matchdeterministicRelation($$dpth + 1, $$cr);
    }
    public matchrelation_3($$dpth: number, $$cr?: ErrorTracker): Nullable<relation_3> {
        return this.matchindexedRelation($$dpth + 1, $$cr);
    }
    public matchrelationSep($$dpth: number, $$cr?: ErrorTracker): Nullable<relationSep> {
        return this.run<relationSep>($$dpth,
            () => {
                let $scope$body: Nullable<relationSep_$0[]>;
                let $$res: Nullable<relationSep> = null;
                if (true
                    && ($scope$body = this.loop<relationSep_$0>(() => this.matchrelationSep_$0($$dpth + 1, $$cr), true)) !== null
                    && this.matchblank($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.relationSep, body: $scope$body};
                }
                return $$res;
            });
    }
    public matchrelationSep_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<relationSep_$0> {
        return this.run<relationSep_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<blank>;
                let $scope$item: Nullable<relationSepItem>;
                let $$res: Nullable<relationSep_$0> = null;
                if (true
                    && ($scope$sep = this.matchblank($$dpth + 1, $$cr)) !== null
                    && ($scope$item = this.matchrelationSepItem($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.relationSep_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchrelationSepItem($$dpth: number, $$cr?: ErrorTracker): Nullable<relationSepItem> {
        return this.choice<relationSepItem>([
            () => this.matchrelationSepItem_1($$dpth + 1, $$cr),
            () => this.matchrelationSepItem_2($$dpth + 1, $$cr),
        ]);
    }
    public matchrelationSepItem_1($$dpth: number, $$cr?: ErrorTracker): Nullable<relationSepItem_1> {
        return this.matchsepItem($$dpth + 1, $$cr);
    }
    public matchrelationSepItem_2($$dpth: number, $$cr?: ErrorTracker): Nullable<relationSepItem_2> {
        return this.run<relationSepItem_2>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<relationSepItem_2> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:;)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.relationSepItem_2, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchrelationList($$dpth: number, $$cr?: ErrorTracker): Nullable<relationList> {
        return this.run<relationList>($$dpth,
            () => {
                let $scope$head: Nullable<relation>;
                let $scope$tail: Nullable<relationList_$0[]>;
                let $$res: Nullable<relationList> = null;
                if (true
                    && ($scope$head = this.matchrelation($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<relationList_$0>(() => this.matchrelationList_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.relationList, head: $scope$head, tail: $scope$tail};
                }
                return $$res;
            });
    }
    public matchrelationList_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<relationList_$0> {
        return this.run<relationList_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<relationSep>;
                let $scope$item: Nullable<relation>;
                let $$res: Nullable<relationList_$0> = null;
                if (true
                    && ($scope$sep = this.matchrelationSep($$dpth + 1, $$cr)) !== null
                    && ($scope$item = this.matchrelation($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.relationList_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchcti($$dpth: number, $$cr?: ErrorTracker): Nullable<cti> {
        return this.run<cti>($$dpth,
            () => {
                let $scope$header: Nullable<ctiHeader>;
                let $scope$lower: Nullable<Nullable<exp>>;
                let $scope$upper: Nullable<Nullable<exp>>;
                let $$res: Nullable<cti> = null;
                if (true
                    && this.matchsep($$dpth + 1, $$cr) !== null
                    && ($scope$header = this.matchctiHeader($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:[(])`, $$dpth + 1, $$cr) !== null
                    && this.matchsep($$dpth + 1, $$cr) !== null
                    && (($scope$lower = this.matchexp($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[,])`, $$dpth + 1, $$cr) !== null
                    && this.matchsep($$dpth + 1, $$cr) !== null
                    && (($scope$upper = this.matchexp($$dpth + 1, $$cr)) || true)
                    && this.matchsep($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:[)])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.cti, header: $scope$header, lower: $scope$lower, upper: $scope$upper};
                }
                return $$res;
            });
    }
    public matchctiHeader($$dpth: number, $$cr?: ErrorTracker): Nullable<ctiHeader> {
        return this.choice<ctiHeader>([
            () => this.matchctiHeader_1($$dpth + 1, $$cr),
            () => this.matchctiHeader_2($$dpth + 1, $$cr),
            () => this.matchctiHeader_3($$dpth + 1, $$cr),
        ]);
    }
    public matchctiHeader_1($$dpth: number, $$cr?: ErrorTracker): Nullable<ctiHeader_1> {
        return this.run<ctiHeader_1>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<ctiHeader_1> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:C)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ctiHeader_1, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchctiHeader_2($$dpth: number, $$cr?: ErrorTracker): Nullable<ctiHeader_2> {
        return this.run<ctiHeader_2>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<ctiHeader_2> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:T)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ctiHeader_2, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchctiHeader_3($$dpth: number, $$cr?: ErrorTracker): Nullable<ctiHeader_3> {
        return this.run<ctiHeader_3>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<ctiHeader_3> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:I)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ctiHeader_3, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchstochasticRelation($$dpth: number, $$cr?: ErrorTracker): Nullable<stochasticRelation> {
        return this.run<stochasticRelation>($$dpth,
            () => {
                let $scope$lhs: Nullable<exp>;
                let $scope$beforeOp: Nullable<sep>;
                let $scope$afterOp: Nullable<sep>;
                let $scope$rhs: Nullable<exp>;
                let $scope$cti: Nullable<Nullable<cti>>;
                let $$res: Nullable<stochasticRelation> = null;
                if (true
                    && ($scope$lhs = this.matchexp($$dpth + 1, $$cr)) !== null
                    && ($scope$beforeOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:~)`, $$dpth + 1, $$cr) !== null
                    && ($scope$afterOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$rhs = this.matchexp($$dpth + 1, $$cr)) !== null
                    && (($scope$cti = this.matchcti($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.stochasticRelation, lhs: $scope$lhs, beforeOp: $scope$beforeOp, afterOp: $scope$afterOp, rhs: $scope$rhs, cti: $scope$cti};
                }
                return $$res;
            });
    }
    public matchdeterministicRelation($$dpth: number, $$cr?: ErrorTracker): Nullable<deterministicRelation> {
        return this.run<deterministicRelation>($$dpth,
            () => {
                let $scope$lhs: Nullable<exp>;
                let $scope$beforeOp: Nullable<sep>;
                let $scope$afterOp: Nullable<sep>;
                let $scope$rhs: Nullable<exp>;
                let $$res: Nullable<deterministicRelation> = null;
                if (true
                    && ($scope$lhs = this.matchexp($$dpth + 1, $$cr)) !== null
                    && ($scope$beforeOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:<-)`, $$dpth + 1, $$cr) !== null
                    && ($scope$afterOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$rhs = this.matchexp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.deterministicRelation, lhs: $scope$lhs, beforeOp: $scope$beforeOp, afterOp: $scope$afterOp, rhs: $scope$rhs};
                }
                return $$res;
            });
    }
    public matchindexedRelation($$dpth: number, $$cr?: ErrorTracker): Nullable<indexedRelation> {
        return this.run<indexedRelation>($$dpth,
            () => {
                let $scope$name: Nullable<name>;
                let $scope$domain: Nullable<exp>;
                let $scope$afterParenR: Nullable<sep>;
                let $scope$body: Nullable<block>;
                let $$res: Nullable<indexedRelation> = null;
                if (true
                    && this.regexAccept(String.raw`(?:for)`, $$dpth + 1, $$cr) !== null
                    && this.matchblank($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && this.matchblank($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchname($$dpth + 1, $$cr)) !== null
                    && this.matchblank($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:in)`, $$dpth + 1, $$cr) !== null
                    && this.matchblank($$dpth + 1, $$cr) !== null
                    && ($scope$domain = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.matchblank($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                    && ($scope$afterParenR = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$body = this.matchblock($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.indexedRelation, name: $scope$name, domain: $scope$domain, afterParenR: $scope$afterParenR, body: $scope$body};
                }
                return $$res;
            });
    }
    public matchblank($$dpth: number, $$cr?: ErrorTracker): Nullable<blank> {
        return this.run<blank>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<blank> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[^\S\n]*)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.blank, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchnewline($$dpth: number, $$cr?: ErrorTracker): Nullable<newline> {
        return this.run<newline>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<newline> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:[\n])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.newline, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchcomment($$dpth: number, $$cr?: ErrorTracker): Nullable<comment> {
        return this.run<comment>($$dpth,
            () => {
                let $scope$content: Nullable<string>;
                let $$res: Nullable<comment> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[#])`, $$dpth + 1, $$cr) !== null
                    && ($scope$content = this.regexAccept(String.raw`(?:[^\n]*)`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:[\n])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.comment, content: $scope$content};
                }
                return $$res;
            });
    }
    public matchsep($$dpth: number, $$cr?: ErrorTracker): Nullable<sep> {
        return this.run<sep>($$dpth,
            () => {
                let $scope$body: Nullable<sep_$0[]>;
                let $$res: Nullable<sep> = null;
                if (true
                    && ($scope$body = this.loop<sep_$0>(() => this.matchsep_$0($$dpth + 1, $$cr), true)) !== null
                    && this.matchblank($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.sep, body: $scope$body};
                }
                return $$res;
            });
    }
    public matchsep_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<sep_$0> {
        return this.run<sep_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<blank>;
                let $scope$item: Nullable<sepItem>;
                let $$res: Nullable<sep_$0> = null;
                if (true
                    && ($scope$sep = this.matchblank($$dpth + 1, $$cr)) !== null
                    && ($scope$item = this.matchsepItem($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.sep_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchsepItem($$dpth: number, $$cr?: ErrorTracker): Nullable<sepItem> {
        return this.choice<sepItem>([
            () => this.matchsepItem_1($$dpth + 1, $$cr),
            () => this.matchsepItem_2($$dpth + 1, $$cr),
        ]);
    }
    public matchsepItem_1($$dpth: number, $$cr?: ErrorTracker): Nullable<sepItem_1> {
        return this.matchnewline($$dpth + 1, $$cr);
    }
    public matchsepItem_2($$dpth: number, $$cr?: ErrorTracker): Nullable<sepItem_2> {
        return this.matchcomment($$dpth + 1, $$cr);
    }
    public matchexp($$dpth: number, $$cr?: ErrorTracker): Nullable<exp> {
        return this.matchexp5($$dpth + 1, $$cr);
    }
    public matchexp0($$dpth: number, $$cr?: ErrorTracker): Nullable<exp0> {
        return this.choice<exp0>([
            () => this.matchexp0_1($$dpth + 1, $$cr),
            () => this.matchexp0_2($$dpth + 1, $$cr),
            () => this.matchexp0_3($$dpth + 1, $$cr),
            () => this.matchexp0_4($$dpth + 1, $$cr),
            () => this.matchexp0_5($$dpth + 1, $$cr),
        ]);
    }
    public matchexp0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<exp0_1> {
        return this.matchscalar($$dpth + 1, $$cr);
    }
    public matchexp0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<exp0_2> {
        return this.matchstructure($$dpth + 1, $$cr);
    }
    public matchexp0_3($$dpth: number, $$cr?: ErrorTracker): Nullable<exp0_3> {
        return this.matchlist($$dpth + 1, $$cr);
    }
    public matchexp0_4($$dpth: number, $$cr?: ErrorTracker): Nullable<exp0_4> {
        return this.run<exp0_4>($$dpth,
            () => {
                let $scope$before: Nullable<sep>;
                let $scope$exp: Nullable<exp5>;
                let $scope$after: Nullable<sep>;
                let $$res: Nullable<exp0_4> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && ($scope$before = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$exp = this.matchexp5($$dpth + 1, $$cr)) !== null
                    && ($scope$after = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.exp0_4, before: $scope$before, exp: $scope$exp, after: $scope$after};
                }
                return $$res;
            });
    }
    public matchexp0_5($$dpth: number, $$cr?: ErrorTracker): Nullable<exp0_5> {
        return this.matchname($$dpth + 1, $$cr);
    }
    public matchexp1($$dpth: number, $$cr?: ErrorTracker): Nullable<exp1> {
        return this.run<exp1>($$dpth,
            () => {
                let $scope$base: Nullable<exp0>;
                let $scope$applications: Nullable<application[]>;
                let $$res: Nullable<exp1> = null;
                if (true
                    && ($scope$base = this.matchexp0($$dpth + 1, $$cr)) !== null
                    && ($scope$applications = this.loop<application>(() => this.matchapplication($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.exp1, base: $scope$base, applications: $scope$applications};
                }
                return $$res;
            });
    }
    public matchexp2($$dpth: number, $$cr?: ErrorTracker): Nullable<exp2> {
        return this.choice<exp2>([
            () => this.matchexp2_1($$dpth + 1, $$cr),
            () => this.matchexp2_2($$dpth + 1, $$cr),
        ]);
    }
    public matchexp2_1($$dpth: number, $$cr?: ErrorTracker): Nullable<exp2_1> {
        return this.run<exp2_1>($$dpth,
            () => {
                let $scope$between: Nullable<sep>;
                let $scope$exp: Nullable<exp1>;
                let $$res: Nullable<exp2_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null
                    && ($scope$between = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$exp = this.matchexp1($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.exp2_1, between: $scope$between, exp: $scope$exp};
                }
                return $$res;
            });
    }
    public matchexp2_2($$dpth: number, $$cr?: ErrorTracker): Nullable<exp2_2> {
        return this.matchexp1($$dpth + 1, $$cr);
    }
    public matchexp3($$dpth: number, $$cr?: ErrorTracker): Nullable<exp3> {
        const fn = () => {
            return this.choice<exp3>([
                () => this.matchexp3_1($$dpth + 1, $$cr),
                () => this.matchexp3_2($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$exp3$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$exp3$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<exp3> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$exp3$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchexp3_1($$dpth: number, $$cr?: ErrorTracker): Nullable<exp3_1> {
        return this.run<exp3_1>($$dpth,
            () => {
                let $scope$left: Nullable<exp3>;
                let $scope$beforeOp: Nullable<sep>;
                let $scope$op: Nullable<addSub>;
                let $scope$afterOp: Nullable<sep>;
                let $scope$right: Nullable<exp2>;
                let $$res: Nullable<exp3_1> = null;
                if (true
                    && ($scope$left = this.matchexp3($$dpth + 1, $$cr)) !== null
                    && ($scope$beforeOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$op = this.matchaddSub($$dpth + 1, $$cr)) !== null
                    && ($scope$afterOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$right = this.matchexp2($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.exp3_1, left: $scope$left, beforeOp: $scope$beforeOp, op: $scope$op, afterOp: $scope$afterOp, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchexp3_2($$dpth: number, $$cr?: ErrorTracker): Nullable<exp3_2> {
        return this.matchexp2($$dpth + 1, $$cr);
    }
    public matchexp4($$dpth: number, $$cr?: ErrorTracker): Nullable<exp4> {
        const fn = () => {
            return this.choice<exp4>([
                () => this.matchexp4_1($$dpth + 1, $$cr),
                () => this.matchexp4_2($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$exp4$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$exp4$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<exp4> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$exp4$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchexp4_1($$dpth: number, $$cr?: ErrorTracker): Nullable<exp4_1> {
        return this.run<exp4_1>($$dpth,
            () => {
                let $scope$left: Nullable<exp4>;
                let $scope$beforeOp: Nullable<sep>;
                let $scope$op: Nullable<mulDiv>;
                let $scope$afterOp: Nullable<sep>;
                let $scope$right: Nullable<exp3>;
                let $$res: Nullable<exp4_1> = null;
                if (true
                    && ($scope$left = this.matchexp4($$dpth + 1, $$cr)) !== null
                    && ($scope$beforeOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$op = this.matchmulDiv($$dpth + 1, $$cr)) !== null
                    && ($scope$afterOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$right = this.matchexp3($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.exp4_1, left: $scope$left, beforeOp: $scope$beforeOp, op: $scope$op, afterOp: $scope$afterOp, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchexp4_2($$dpth: number, $$cr?: ErrorTracker): Nullable<exp4_2> {
        return this.matchexp3($$dpth + 1, $$cr);
    }
    public matchexp5($$dpth: number, $$cr?: ErrorTracker): Nullable<exp5> {
        const fn = () => {
            return this.choice<exp5>([
                () => this.matchexp5_1($$dpth + 1, $$cr),
                () => this.matchexp5_2($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$exp5$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$exp5$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<exp5> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$exp5$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchexp5_1($$dpth: number, $$cr?: ErrorTracker): Nullable<exp5_1> {
        return this.run<exp5_1>($$dpth,
            () => {
                let $scope$left: Nullable<exp5>;
                let $scope$beforeOp: Nullable<sep>;
                let $scope$afterOp: Nullable<sep>;
                let $scope$right: Nullable<exp4>;
                let $$res: Nullable<exp5_1> = null;
                if (true
                    && ($scope$left = this.matchexp5($$dpth + 1, $$cr)) !== null
                    && ($scope$beforeOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?::)`, $$dpth + 1, $$cr) !== null
                    && ($scope$afterOp = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$right = this.matchexp4($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.exp5_1, left: $scope$left, beforeOp: $scope$beforeOp, afterOp: $scope$afterOp, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchexp5_2($$dpth: number, $$cr?: ErrorTracker): Nullable<exp5_2> {
        return this.matchexp4($$dpth + 1, $$cr);
    }
    public matchapplication($$dpth: number, $$cr?: ErrorTracker): Nullable<application> {
        return this.choice<application>([
            () => this.matchapplication_1($$dpth + 1, $$cr),
            () => this.matchapplication_2($$dpth + 1, $$cr),
        ]);
    }
    public matchapplication_1($$dpth: number, $$cr?: ErrorTracker): Nullable<application_1> {
        return this.matchfunctionApplication($$dpth + 1, $$cr);
    }
    public matchapplication_2($$dpth: number, $$cr?: ErrorTracker): Nullable<application_2> {
        return this.matchvectorApplication($$dpth + 1, $$cr);
    }
    public matchfunctionApplication($$dpth: number, $$cr?: ErrorTracker): Nullable<functionApplication> {
        return this.run<functionApplication>($$dpth,
            () => {
                let $scope$beforeParen: Nullable<sep>;
                let $scope$beginArgs: Nullable<sep>;
                let $scope$operands: Nullable<argumentList>;
                let $scope$endArgs: Nullable<sep>;
                let $$res: Nullable<functionApplication> = null;
                if (true
                    && ($scope$beforeParen = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && ($scope$beginArgs = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$operands = this.matchargumentList($$dpth + 1, $$cr)) !== null
                    && ($scope$endArgs = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.functionApplication, beforeParen: $scope$beforeParen, beginArgs: $scope$beginArgs, operands: $scope$operands, endArgs: $scope$endArgs};
                }
                return $$res;
            });
    }
    public matchvectorApplication($$dpth: number, $$cr?: ErrorTracker): Nullable<vectorApplication> {
        return this.run<vectorApplication>($$dpth,
            () => {
                let $scope$beforeParen: Nullable<sep>;
                let $scope$beginInds: Nullable<sep>;
                let $scope$operands: Nullable<indexList>;
                let $scope$endInds: Nullable<sep>;
                let $$res: Nullable<vectorApplication> = null;
                if (true
                    && ($scope$beforeParen = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && ($scope$beginInds = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$operands = this.matchindexList($$dpth + 1, $$cr)) !== null
                    && ($scope$endInds = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.vectorApplication, beforeParen: $scope$beforeParen, beginInds: $scope$beginInds, operands: $scope$operands, endInds: $scope$endInds};
                }
                return $$res;
            });
    }
    public matchaddSub($$dpth: number, $$cr?: ErrorTracker): Nullable<addSub> {
        return this.choice<addSub>([
            () => this.matchaddSub_1($$dpth + 1, $$cr),
            () => this.matchaddSub_2($$dpth + 1, $$cr),
        ]);
    }
    public matchaddSub_1($$dpth: number, $$cr?: ErrorTracker): Nullable<addSub_1> {
        return this.run<addSub_1>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<addSub_1> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.addSub_1, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchaddSub_2($$dpth: number, $$cr?: ErrorTracker): Nullable<addSub_2> {
        return this.run<addSub_2>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<addSub_2> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.addSub_2, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchmulDiv($$dpth: number, $$cr?: ErrorTracker): Nullable<mulDiv> {
        return this.choice<mulDiv>([
            () => this.matchmulDiv_1($$dpth + 1, $$cr),
            () => this.matchmulDiv_2($$dpth + 1, $$cr),
        ]);
    }
    public matchmulDiv_1($$dpth: number, $$cr?: ErrorTracker): Nullable<mulDiv_1> {
        return this.run<mulDiv_1>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<mulDiv_1> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:\*)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.mulDiv_1, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchmulDiv_2($$dpth: number, $$cr?: ErrorTracker): Nullable<mulDiv_2> {
        return this.run<mulDiv_2>($$dpth,
            () => {
                let $scope$v: Nullable<string>;
                let $$res: Nullable<mulDiv_2> = null;
                if (true
                    && ($scope$v = this.regexAccept(String.raw`(?:/)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.mulDiv_2, v: $scope$v};
                }
                return $$res;
            });
    }
    public matchlist($$dpth: number, $$cr?: ErrorTracker): Nullable<list> {
        return this.run<list>($$dpth,
            () => {
                let $scope$beforeFields: Nullable<sep>;
                let $scope$operands: Nullable<fieldList>;
                let $scope$afterFields: Nullable<sep>;
                let $$res: Nullable<list> = null;
                if (true
                    && this.regexAccept(String.raw`(?:list[(])`, $$dpth + 1, $$cr) !== null
                    && ($scope$beforeFields = this.matchsep($$dpth + 1, $$cr)) !== null
                    && ($scope$operands = this.matchfieldList($$dpth + 1, $$cr)) !== null
                    && ($scope$afterFields = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:[)])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.list, beforeFields: $scope$beforeFields, operands: $scope$operands, afterFields: $scope$afterFields};
                }
                return $$res;
            });
    }
    public matchstructure($$dpth: number, $$cr?: ErrorTracker): Nullable<structure> {
        return this.run<structure>($$dpth,
            () => {
                let $scope$begin: Nullable<sep>;
                let $scope$sepDotData: Nullable<sep>;
                let $scope$eqData: Nullable<nameValueSep>;
                let $scope$data: Nullable<exp>;
                let $scope$sepDotDim: Nullable<sep>;
                let $scope$eqDim: Nullable<nameValueSep>;
                let $scope$dim: Nullable<exp>;
                let $scope$end: Nullable<sep>;
                let $$res: Nullable<structure> = null;
                if (true
                    && this.regexAccept(String.raw`(?:structure[(])`, $$dpth + 1, $$cr) !== null
                    && ($scope$begin = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\.)`, $$dpth + 1, $$cr) !== null
                    && ($scope$sepDotData = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:Data)`, $$dpth + 1, $$cr) !== null
                    && ($scope$eqData = this.matchnameValueSep($$dpth + 1, $$cr)) !== null
                    && ($scope$data = this.matchexp($$dpth + 1, $$cr)) !== null
                    && this.matchoperandSep($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\.)`, $$dpth + 1, $$cr) !== null
                    && ($scope$sepDotDim = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:Dim)`, $$dpth + 1, $$cr) !== null
                    && ($scope$eqDim = this.matchnameValueSep($$dpth + 1, $$cr)) !== null
                    && ($scope$dim = this.matchexp($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:[)])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.structure, begin: $scope$begin, sepDotData: $scope$sepDotData, eqData: $scope$eqData, data: $scope$data, sepDotDim: $scope$sepDotDim, eqDim: $scope$eqDim, dim: $scope$dim, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchoperandSep($$dpth: number, $$cr?: ErrorTracker): Nullable<operandSep> {
        return this.run<operandSep>($$dpth,
            () => {
                let $scope$before: Nullable<sep>;
                let $scope$after: Nullable<sep>;
                let $$res: Nullable<operandSep> = null;
                if (true
                    && ($scope$before = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && ($scope$after = this.matchsep($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.operandSep, before: $scope$before, after: $scope$after};
                }
                return $$res;
            });
    }
    public matchargument($$dpth: number, $$cr?: ErrorTracker): Nullable<argument> {
        return this.matchexp($$dpth + 1, $$cr);
    }
    public matchargumentList($$dpth: number, $$cr?: ErrorTracker): Nullable<argumentList> {
        return this.run<argumentList>($$dpth,
            () => {
                let $scope$content: Nullable<Nullable<argumentList_$0>>;
                let $$res: Nullable<argumentList> = null;
                if (true
                    && (($scope$content = this.matchargumentList_$0($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.argumentList, content: $scope$content};
                }
                return $$res;
            });
    }
    public matchargumentList_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<argumentList_$0> {
        return this.run<argumentList_$0>($$dpth,
            () => {
                let $scope$first: Nullable<argument>;
                let $scope$rest: Nullable<argumentList_$0_$0[]>;
                let $$res: Nullable<argumentList_$0> = null;
                if (true
                    && ($scope$first = this.matchargument($$dpth + 1, $$cr)) !== null
                    && ($scope$rest = this.loop<argumentList_$0_$0>(() => this.matchargumentList_$0_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.argumentList_$0, first: $scope$first, rest: $scope$rest};
                }
                return $$res;
            });
    }
    public matchargumentList_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<argumentList_$0_$0> {
        return this.run<argumentList_$0_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<operandSep>;
                let $scope$item: Nullable<argument>;
                let $$res: Nullable<argumentList_$0_$0> = null;
                if (true
                    && ($scope$sep = this.matchoperandSep($$dpth + 1, $$cr)) !== null
                    && ($scope$item = this.matchargument($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.argumentList_$0_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchindexList($$dpth: number, $$cr?: ErrorTracker): Nullable<indexList> {
        return this.run<indexList>($$dpth,
            () => {
                let $scope$content: Nullable<Nullable<indexList_$0>>;
                let $$res: Nullable<indexList> = null;
                if (true
                    && (($scope$content = this.matchindexList_$0($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.indexList, content: $scope$content};
                }
                return $$res;
            });
    }
    public matchindexList_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<indexList_$0> {
        return this.run<indexList_$0>($$dpth,
            () => {
                let $scope$first: Nullable<Nullable<exp>>;
                let $scope$rest: Nullable<indexList_$0_$0[]>;
                let $$res: Nullable<indexList_$0> = null;
                if (true
                    && (($scope$first = this.matchexp($$dpth + 1, $$cr)) || true)
                    && ($scope$rest = this.loop<indexList_$0_$0>(() => this.matchindexList_$0_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.indexList_$0, first: $scope$first, rest: $scope$rest};
                }
                return $$res;
            });
    }
    public matchindexList_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<indexList_$0_$0> {
        return this.run<indexList_$0_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<operandSep>;
                let $scope$item: Nullable<Nullable<exp>>;
                let $$res: Nullable<indexList_$0_$0> = null;
                if (true
                    && ($scope$sep = this.matchoperandSep($$dpth + 1, $$cr)) !== null
                    && (($scope$item = this.matchexp($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.indexList_$0_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchfield($$dpth: number, $$cr?: ErrorTracker): Nullable<field> {
        return this.run<field>($$dpth,
            () => {
                let $scope$name: Nullable<name>;
                let $scope$sep: Nullable<nameValueSep>;
                let $scope$value: Nullable<exp>;
                let $$res: Nullable<field> = null;
                if (true
                    && ($scope$name = this.matchname($$dpth + 1, $$cr)) !== null
                    && ($scope$sep = this.matchnameValueSep($$dpth + 1, $$cr)) !== null
                    && ($scope$value = this.matchexp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.field, name: $scope$name, sep: $scope$sep, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchfieldList($$dpth: number, $$cr?: ErrorTracker): Nullable<fieldList> {
        return this.run<fieldList>($$dpth,
            () => {
                let $scope$content: Nullable<Nullable<fieldList_$0>>;
                let $$res: Nullable<fieldList> = null;
                if (true
                    && (($scope$content = this.matchfieldList_$0($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.fieldList, content: $scope$content};
                }
                return $$res;
            });
    }
    public matchfieldList_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<fieldList_$0> {
        return this.run<fieldList_$0>($$dpth,
            () => {
                let $scope$first: Nullable<field>;
                let $scope$rest: Nullable<fieldList_$0_$0[]>;
                let $$res: Nullable<fieldList_$0> = null;
                if (true
                    && ($scope$first = this.matchfield($$dpth + 1, $$cr)) !== null
                    && ($scope$rest = this.loop<fieldList_$0_$0>(() => this.matchfieldList_$0_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.fieldList_$0, first: $scope$first, rest: $scope$rest};
                }
                return $$res;
            });
    }
    public matchfieldList_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<fieldList_$0_$0> {
        return this.run<fieldList_$0_$0>($$dpth,
            () => {
                let $scope$sep: Nullable<operandSep>;
                let $scope$item: Nullable<field>;
                let $$res: Nullable<fieldList_$0_$0> = null;
                if (true
                    && ($scope$sep = this.matchoperandSep($$dpth + 1, $$cr)) !== null
                    && ($scope$item = this.matchfield($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.fieldList_$0_$0, sep: $scope$sep, item: $scope$item};
                }
                return $$res;
            });
    }
    public matchnameValueSep($$dpth: number, $$cr?: ErrorTracker): Nullable<nameValueSep> {
        return this.run<nameValueSep>($$dpth,
            () => {
                let $scope$before: Nullable<sep>;
                let $scope$after: Nullable<sep>;
                let $$res: Nullable<nameValueSep> = null;
                if (true
                    && ($scope$before = this.matchsep($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr) !== null
                    && ($scope$after = this.matchsep($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.nameValueSep, before: $scope$before, after: $scope$after};
                }
                return $$res;
            });
    }
    public matchname($$dpth: number, $$cr?: ErrorTracker): Nullable<name> {
        return this.run<name>($$dpth,
            () => {
                let $scope$from: Nullable<PosInfo>;
                let $scope$value: Nullable<string>;
                let $scope$to: Nullable<PosInfo>;
                let $$res: Nullable<name> = null;
                if (true
                    && ($scope$from = this.mark()) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:[a-zA-Z][a-zA-Z0-9._]*)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$to = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.name, from: $scope$from, value: $scope$value, to: $scope$to};
                }
                return $$res;
            });
    }
    public matchscalar($$dpth: number, $$cr?: ErrorTracker): Nullable<scalar> {
        return this.run<scalar>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<scalar> = null;
                if (true
                    && ($scope$value = this.regexAccept(String.raw`(?:-?([\d]+([.][\d]+)?|([\d]+)?[.][\d]+)([eE]-?[\d]+)?)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.scalar, value: $scope$value};
                }
                return $$res;
            });
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchprogram(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchprogram(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchprogram(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<program>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}