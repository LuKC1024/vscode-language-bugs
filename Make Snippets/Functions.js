{
	let notations = [
		"abs(e)",
		"arccos(e)",
		"arccosh(e)",
		"arcsin(e)",
		"arcsinh(e)",
		"arctan(e)",
		"arctanh(e)",
		"cloglog(e)",
		"cos(e)",
		"cosh(e)",
		"cumulative(s1, s2)",
		"cut(e)",
		"density(s1, s2)",
		"deviance(s1, s2)",
		"equals(e1, e2)",
		"exp(e)",
		"gammap(s1, s2)",
		"ilogit(e)",
		"icloglog(e)",
		"integral(F(s), s1, s2, s3)",
		"log(e)",
		"logfact(e)",
		"loggam(e)",
		"logit(e)",
		"max(e1, e2)",
		"min(e1, e2)",
		"phi(e)",
		"post.p.value(s)",
		"pow(e1, e2)",
		"prior.p.value(s)",
		"probit(e)",
		"replicate.post(s)",
		"replicate.prior(s)",
		"round(e)",
		"sin(e)",
		"sinh(e)",
		"solution(F(s), s1, s2, s3)",
		"sqrt(e)",
		"step(e)",
		"tan(e)",
		"tanh(e)",
		"trunc(e)",
		"inprod(v1, v2)",
		"interp.lin(e, v1, v2)",
		"inverse(v)",
		"logdet(v)",
		"mean(v)",
		"eigen.vals(v)",
		"ode(v1, v2, D(v3, s1), s2, s3)",
		"prod(v)",
		"p.valueM(v)",
		"rank(v, s)",
		"ranked(v, s)",
		"replicate.postM(v)",
		"sd(v)",
		"sort(v)",
		"sum(v)"
	];
	let descriptions = [
		"absolute value of e, |e|",
		"inverse cosine of e",
		"inverse hyperbolic cosine of e",
		"inverse sine of e",
		"inverse hyperbolic sine of e",
		"inverse tangent of e",
		"inverse hyperbolic tangent of e",
		"complementary log log of e, ln(- ln(1 - e))",
		"cosine of e",
		"hyperbolic cosine of e",
		"tail area of distribution of s1 up to the value of s2, s1 must be stochastic, s1 and s2 can be the same",
		"cuts edges in the graph.",
		"density of distribution of s1 at value of s2, s1 must be a stochastic node supplied as data, s1 and s2 can be the same.",
		"deviance of distribution of s1 at value of s2, s1 must be a stochastic node supplied as data, s1 and s2 can be the same.",
		"1 if value of e 1 equals value of e 2; 0 otherwise",
		"exp(e)",
		"partial (incomplete) gamma function, value of standard gamma density with parameter s1 integrated up to s2",
		"exp(e) / (1 + exp(e))",
		"1 - exp(- exp(e))",
		"definite integral of function F(s) between s = s1 and s = s2 to accuracy s3",
		"natural logarithm of e",
		"ln(e!)",
		"logarithm of gamma function of e",
		"ln(e / (1 - e))",
		"e1 if e1 > e2; e2 otherwise",
		"e1 if e1 < e2; e2 otherwise",
		"standard normal cdf",
		"s must be a stochastic node, returns one if a sample from the prior is less than the value of s",
		"e1 ^ e2",
		"s must be a stochastic node, returns one if a sample from the prior after resampling its stochastic parents is less than value of s.",
		"inverse of phi(e)",
		"replicate from distribution of s, s must be stochastic node",
		"replicate from distribution of s after replicating from it parents if they are stochastic, s must be stochastic node",
		"nearest integer to e",
		"sine of e",
		"hyperbolic sine of e",
		"a solution of equation F(s) = 0 lying between s = s1 and s = s2 to accuracy s3, s1 and s2 must bracket a solution",
		"e ^ (1 / 2)",
		"1 if e >= 0; 0 otherwise",
		"tangent of e",
		"hyperbolic tangent of e",
		"greatest integer less than or equal to e",
		"inner product of v1 and v2, Σᵢ v1ᵢv2ᵢ",
		"v2ₚ + (v2ₚ₊₁ - v2ₚ) * (e - v1ₚ) / (v1ₚ + 1 - v1ₚ) where the elements of v1 are in ascending order and p is such that v1ₚ < e < v1ₚ₊₁.\nGiven function values in the vector v2 evaluated at the points in v1, this estimates the function value at a new point e by simple linear interpolation using the closest bounding pair of points. For example, given the population in 1991, 2001 and 2011, we might want to estimate the population in 2004.",
		"inverse of symmetric positive-definite matrix v",
		"log of determinant of v for symmetric positive-definite",
		"Σᵢ (vᵢ / n) where n = dim(v)",
		"eigenvalues of matrix v",
		"solution of system of ordinary differential equations at grid of points v2 given initial values v1 at time s2 solved to accuracy s3. v3 is a vector of components of the system of ode and s1 is the time variable.",
		"Πᵢ vᵢ",
		"v must be a multivariate stochastic node, returns a vector of ones and zeros depending on if a sample from the prior is less than value of the corresponding component of v",
		"number of components of v less than or equal to s",
		"the s th smallest component of v",
		"replicate from multivariate distribution of v, v must be stochastic and multivariate",
		"standard deviation of components of v (n - 1 in denominator)",
		"vector v sorted in ascending order",
		"Σᵢ vᵢ"
	]
	let snippets = [...notations.keys()].
		map((i) => {
			let notation = notations[i];
			let description = descriptions[i];
			let name = notation.match(/(.*)\(/)[1];
			let args = notation.match(/\(.*\)/)[0].slice(1, -1).split(", ");
			let stringifyArg = (a, i) => {
				return "${" + (i + 1) + ":" + a + "}";
			}
			return [
				name,
				{
					"prefix": name,
					"body": name + "(" + args.map(stringifyArg).join(", ") + ")",
					description
				}
			]
		})
	console.log(JSON.stringify(Object.fromEntries(snippets), null, "\t"))
}